\chapter{Diseño e Implementación}
\title{Diseño e Implementación}
\label{cap:DisenoEImplementacion}
Este proyecto se realiza atendiendo a dos partes, ambas muy importantes y claramente diferenciadas. Por una parte, se ha creado el diseño del prototipo de cliente y por otra parte se ha elaborado el boceto de la interfaz con su posterior diseño de interfaz de usuario.

\section{Diseño del Prototipo del Cliente}
El diseño del prototipo del cliente es la pieza fundamental del proyecto ya que sobre dicho prototipo giran todas las cosas.\\

La función principal del prototipo es permitir conectarnos con cualquier servidor INDI y una vez que establecemos la conexión, mediante el WebSocket, es fundamental que la comunicación se establezca de forma continua con el fin de recibir los diferentes dispositivos que se encuentran conectados con el servidor en concreto y así poder intercambiar mensajes con los parámetros que se van modificando en ambas partes.

\subsection{Métodos en el Fichero \textit{connection.js}}
El cometido de estos métodos es establecer la conexión con el servidor.
También, en ese archivo, se pueden encontrar los métodos para poder realizar el envío de valor de los parámetros modificados, ya sea de tipo \textit{text}, \textit{number}, \textit{switch} o \textit{blob}, al servidor mediante el \textit{WebSocket}, que se crea en el momento de la conexión.

\subsection{Métodos en el Fichero \textit{parserDefVector.js}}
Este fichero se establece en dos grandes bloques. En primer lugar, se encuentran los métodos mediante los cuales se va creando la interfaz con los datos que se reciben del fichero XML, como pueden ser, entre otros, los nombres de los dispositivos, los nombres de las propiedades, los apelativos de los grupos de las propiedades, los valores que tienen dichas propiedades, etc. En segundo lugar, se hallan las funciones auxiliares para crear dicha interfaz y que sirven de apoyo a los métodos de análisis y parseo de las propiedades.\\

Una vez que llegan esos datos se crean las diferentes ventanas que corresponden a cada dispositivo siempre y cuando estos dispositivos no estén ya creados.
Tanto para las propiedades de \textbf{texto} como para las de \textbf{número} se realiza el mismo proceso.\\

A continuación, se pone una bombilla del color correspondiente según el estado que envíe el fichero XML que proviene del servidor, y el nombre de la propiedad. Este conjunto se ha denominado \textit{propertyBox}.
Seguidamente, mediante el parseo del fichero XML, se va recorriendo cada uno de los nodos que lo van formando y para cada uno de ellos se muestra el nombre que viene descrito mediante el campo \textit{label} y su correspondiente valor del nodo. Al conjunto formado por el nombre y el valor se le ha denominado \textit{elementBoxContainer}.\\

Posteriormente, y según el tipo de permiso que tenga esa propiedad, se pone o no el botón de actualizar para que en el futuro se puedan modificar los campos y poder así enviarle el mensaje al servidor.\\

Por último, se añade a las diferentes pestañas la propiedad, según el grupo al que pertenece la propiedad que se está analizando.\\

Para el análisis y posterior parseo de la propiedad \textbf{\textit{switch}} se sigue el mismo itinerario con el que se ha procedido en los \textit{text} y en los \textit{number}, con la diferencia de que en la parte del \textit{elementBoxContainer}, se hacen diferentes tipos de llamadas para cada una de las diferentes reglas  que pueden contener las propiedades \textit{switch}:
\begin{itemize}
  \item \textbf{\textit{One Of Many:}} se crea un desplegable que siempre obliga al usuario a tener una opción seleccionada en ella.
  \item \textbf{\textit{At Most One:}} se crea un desplegable que permite al usuario si así lo desea o le es factible, solo seleccionar una de todas las opciones que se muestran en él.
  \item \textbf{\textit{Any Of Many:}} se crea un conjunto de opciones que le permitirán al usuario seleccionar todas las que se deseen.
\end{itemize}
Según el tipo de permiso que tenga esa propiedad, se dispone o no, el botón de actualizar para que en el futuro se puedan modificar los campos y poder enviarle el mensaje al servidor.\\

Para el análisis y parseo de la propiedad \textbf{\textit{blob}}, se ha seguido también el mismo procedimiento que en las diferentes propiedades pero en este caso, se ha hecho una pequeña variante en la parte del \textit{elementBoxContainer}. Dentro de ella se muestra, igualmente, el nombre y el valor de la propiedad y además, se añaden dos campos nuevos que son el tamaño del \textit{blob} y su correspondiente formato.
De igual forma, en su parte derecha, y siempre dependiendo  del tipo de permiso que corresponda, se añade o no el botón de actualizar para enviar los datos al servidor.\\

En último lugar, hay que decir que en la parte del análisis y su correspondiente parseo sobre la propiedad \textbf{\textit{light}}, se realiza lo mismo que en las diferentes propiedades salvo en el \textit{elementBoxContainer} que se añade el nombre de la propiedad y el color de la bombilla correspondiente al valor que se envía en ese nodo.\\

Hay que destacar que esta propiedad es siempre del tipo solo lectura y por tanto, no se agregará nunca un botón ya que no se pueden cambiar los valores que tiene.\\

Por otra parte, hay que destacar los métodos auxiliares para la creación del interfaz. Estos métodos son de igual o más importancia que los anteriores ya que sin ellos no se podrían crear las ventanas, poner los diferentes tipos de interruptores o incorporar las diferentes pestañas a las ventanas de los dispositivos.\\

\subsection{Métodos en el Fichero \textit{parserSetVector.js}}
Están constituidos por un total de cinco métodos, uno para cada una de las diferentes propiedades que dispone INDI.
La función principal de estos cinco métodos es común a todos y es la de almacenar los diferentes valores que se cambian en el prototipo de cliente para poder enviárselos al servidor.
Actualmente, en el prototipo, la función de envío se está realizando sobre los propios botones, sobre los desplegables o sobre los \textit{checkbox} que se han ido creando dinámicamente en el fichero anterior. En esos botones se realiza la llamada que corresponda al envío según la propiedad y se hace todo el envío desde el fichero connection.js como se ha mencionado anteriormente.

\subsection{Métodos en el Fichero \textit{parser.html}}
Es el punto de partida de todo el proceso. Desde ahí se establece la conexión con el servidor y se crea un bucle mediante el cual se va enviando la información a las diferentes funciones según el tipo de propiedad que se esté recibiendo o enviando.
También dispone de un conjunto de funciones auxiliares que son comunes tanto a \textit{parserDefVector.js} como a \textit{parserSetVector.js}. Estas pueden ser, por ejemplo, el obtener el nombre de las funciones o conseguir lograr el tipo de bombilla a poner, entre otras.
